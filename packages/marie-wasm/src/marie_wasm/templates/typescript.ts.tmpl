// Marie Node TypeScript Wrapper
// Aligned with Cloudflare Workers naming conventions
//
// This wrapper is injected around user code to provide:
// - Error handling with structured responses
// - Input/env/context injection
// - Return type validation
// - Logging integration
//
// WIT imports are mapped by esbuild during bundling.

import { log, LogLevel } from 'marie:node/console';

// ============================================
// TYPE DEFINITIONS
// ============================================

/** Data item flowing through the workflow */
interface Item {
    json: string;
    binary?: number[] | null;
}

/** Execution context */
interface Context {
    workflowId: string;
    executionId: string;
    nodeId: string;
    runIndex: number;
}

/** Response types */
type Response = { ok: Item[] } | { err: string };

// ============================================
// USER CODE START
// User defines: function execute(input: Item[], env: Record<string, unknown>, ctx: Context): Response
// ============================================

{USER_CODE}

// ============================================
// USER CODE END
// ============================================

/**
 * Internal wrapper that calls the user's execute function with error handling.
 * This is the component's exported execute function.
 */
function _marie_execute(
    inputItems: Array<{ json: string; binary?: number[] | null }>,
    env: { vars: string },
    ctx: { workflowId: string; executionId: string; nodeId: string; runIndex: number }
): { ok: Array<{ json: string; binary: number[] | null }> } | { err: string } {
    try {
        // Parse env vars JSON for user convenience
        let vars: Record<string, unknown> = {};
        try {
            vars = env.vars ? JSON.parse(env.vars) : {};
        } catch (e) {
            log(LogLevel.WARN, `Failed to parse env vars JSON: ${(e as Error).message}`);
        }

        // Convert to user-friendly format
        const input: Item[] = inputItems.map(item => ({
            json: item.json,
            binary: item.binary ?? null,
        }));

        const context: Context = {
            workflowId: ctx.workflowId,
            executionId: ctx.executionId,
            nodeId: ctx.nodeId,
            runIndex: ctx.runIndex,
        };

        // Call user's execute function (defined in USER CODE section)
        const result = execute(input, vars, context);

        // Validate return type
        if (result === null || result === undefined) {
            log(LogLevel.ERROR, 'execute() returned null/undefined');
            return { err: 'execute() must return an object with "ok" or "err" key' };
        }

        if (typeof result !== 'object') {
            log(LogLevel.ERROR, `execute() must return an object, got ${typeof result}`);
            return { err: 'execute() must return an object with "ok" or "err" key' };
        }

        if ('err' in result) {
            return { err: String(result.err) };
        }

        if (!('ok' in result)) {
            log(LogLevel.ERROR, 'execute() must return {ok: [...]} or {err: "..."}');
            return { err: 'execute() must return {ok: [...]} or {err: "..."}' };
        }

        // Convert output to Items
        const outputItems = result.ok.map(item => {
            if (typeof item === 'object' && item !== null) {
                const jsonStr = item.json !== undefined ? item.json : JSON.stringify(item);
                const binary = item.binary ? Array.from(item.binary) : null;
                return { json: jsonStr, binary };
            } else {
                return { json: JSON.stringify(item), binary: null };
            }
        });

        return { ok: outputItems };

    } catch (e) {
        const error = e as Error;
        const errorMsg = `Execution error: ${error.message || e}`;
        log(LogLevel.ERROR, errorMsg);
        if (error.stack) {
            log(LogLevel.ERROR, error.stack);
        }
        return { err: errorMsg };
    }
}

// Export the wrapper as the component's execute function
export { _marie_execute as execute };
