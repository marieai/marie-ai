"use strict";(self.webpackChunkmare_ai=self.webpackChunkmare_ai||[]).push([[9537],{28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var i=r(96540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}},30734:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"extract/scheduler","title":"Marie Scheduler: Execution and Scheduling Behavior","description":"Overview","source":"@site/docs/extract/scheduler.md","sourceDirName":"extract","slug":"/extract/scheduler","permalink":"/docs/extract/scheduler","draft":false,"unlisted":false,"editUrl":"https://github.com/marieai/marie-ai/tree/main/docs/docs/extract/scheduler.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Role Hints","permalink":"/docs/extract/roles"},"next":{"title":"Marie Scheduler: SLA-Based Job Priority Design","permalink":"/docs/extract/sla"}}');var s=r(74848),t=r(28453);const l={},a="Marie Scheduler: Execution and Scheduling Behavior",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Scheduling Strategy",id:"scheduling-strategy",level:2},{value:"SLA-Based Priority System",id:"sla-based-priority-system",level:2},{value:"Priority Semantics",id:"priority-semantics",level:3},{value:"Priority Tiers",id:"priority-tiers",level:3},{value:"Priority Update Logic",id:"priority-update-logic",level:3},{value:"GlobalPriorityExecutionPlanner",id:"globalpriorityexecutionplanner",level:2},{value:"Sort Order:",id:"sort-order",level:3},{value:"ASCII Diagram: Global Priority Execution Planner",id:"ascii-diagram-global-priority-execution-planner",level:2},{value:"DAG-Level Completion",id:"dag-level-completion",level:2},{value:"ASCII Diagram: DAG-Level Resolution Flow",id:"ascii-diagram-dag-level-resolution-flow",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Pluggable Execution Planner Interface",id:"pluggable-execution-planner-interface",level:2},{value:"Default Planner: <code>GlobalPriorityExecutionPlanner</code>",id:"default-planner-globalpriorityexecutionplanner",level:3},{value:"Alternative Planners",id:"alternative-planners",level:3},{value:"<code>HRRNExecutionPlanner</code> \u2014 Highest Response Ratio Next",id:"hrrnexecutionplanner--highest-response-ratio-next",level:4},{value:"<code>SJFSExecutionPlanner</code> \u2014 Shortest Job First",id:"sjfsexecutionplanner--shortest-job-first",level:4},{value:"Swapping Planners",id:"swapping-planners",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"marie-scheduler-execution-and-scheduling-behavior",children:"Marie Scheduler: Execution and Scheduling Behavior"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"This document describes the scheduling and execution flow used by the Marie Scheduler. It explains how the system selects and dispatches jobs across distributed executors using dynamic, SLA-aware strategies and resource constraints."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"scheduling-strategy",children:"Scheduling Strategy"}),"\n",(0,s.jsx)(n.p,{children:"Marie Scheduler uses a global planner that evaluates job execution order based on multiple criteria:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Critical-path preference"})," \u2014 Jobs deeper in the DAG are prioritized to unblock dependent jobs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SLA-based priority"})," \u2014 Jobs closer to (or past) their SLA deadlines are ranked higher."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Executor capacity"})," \u2014 Jobs targeting executors with more free slots are favored."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DAG reuse"})," \u2014 Existing DAGs are preferred to avoid startup overhead."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Estimated runtime"})," \u2014 Shorter jobs are scheduled first when other factors are equal."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Burst boost"})," \u2014 Recently activated DAGs are temporarily boosted to minimize cold start latency."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"sla-based-priority-system",children:"SLA-Based Priority System"}),"\n",(0,s.jsx)(n.p,{children:"Marie Scheduler calculates a numeric priority score for every job based on SLA deadlines. These values are used directly by the global planner to determine execution order."}),"\n",(0,s.jsx)(n.h3,{id:"priority-semantics",children:"Priority Semantics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Higher values = more urgent"})}),"\n",(0,s.jsx)(n.li,{children:"Jobs are scored using 15-minute time buckets"}),"\n",(0,s.jsx)(n.li,{children:"Late jobs accumulate higher scores as time passes"}),"\n",(0,s.jsx)(n.li,{children:"Upcoming jobs receive lower scores inversely weighted by time"}),"\n",(0,s.jsxs)(n.li,{children:["Jobs with no SLA are assigned the lowest score (",(0,s.jsx)(n.code,{children:"0"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"priority-tiers",children:"Priority Tiers"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Tier"}),(0,s.jsx)(n.th,{children:"Condition"}),(0,s.jsx)(n.th,{children:"Priority Range"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Overdue Hard SLA"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"NOW() > hard_sla"})}),(0,s.jsx)(n.td,{children:"1000\u20131999"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Overdue Soft SLA"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"NOW() > soft_sla"})," (no hard SLA)"]}),(0,s.jsx)(n.td,{children:"500\u2013999"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Upcoming Soft SLA"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"soft_sla > NOW()"})}),(0,s.jsx)(n.td,{children:"1\u2013499"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"No SLA"})}),(0,s.jsx)(n.td,{children:"SLA not defined"}),(0,s.jsx)(n.td,{children:"0"})]})]})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each bucket = 15 minutes (900 seconds)"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"LEAST(...)"})," and ",(0,s.jsx)(n.code,{children:"GREATEST(...)"})," clamp scores to prevent runaway values or negatives"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"priority-update-logic",children:"Priority Update Logic"}),"\n",(0,s.jsx)(n.p,{children:"The following SQL logic is used by the Marie Scheduler to update job priorities:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE OR REPLACE FUNCTION marie_scheduler.refresh_job_priority()\nRETURNS void AS $$\nDECLARE\n    now_time TIMESTAMP := NOW();\nBEGIN\n    UPDATE marie_scheduler.job\n    SET priority = (\n          CASE\n            WHEN hard_sla IS NOT NULL AND NOW() > hard_sla THEN\n              1000 + LEAST(\n                999,\n                FLOOR(EXTRACT(EPOCH FROM (NOW() - hard_sla)) / 900)\n              )  -- overdue hard SLA\n            WHEN soft_sla IS NOT NULL AND NOW() > soft_sla THEN\n              500 + LEAST(\n                499,\n                FLOOR(EXTRACT(EPOCH FROM (NOW() - soft_sla)) / 900)\n              )   -- overdue soft SLA\n            WHEN soft_sla IS NOT NULL THEN\n              GREATEST(\n                1,\n                500 - CEIL(EXTRACT(EPOCH FROM (soft_sla - NOW())) / 900)\n              )   -- upcoming soft SLA\n            ELSE\n              0   -- no SLA\n        END\n    )\n    WHERE state IN ('created', 'retry');\nEND;\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"This function is called:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"After N (default 10) job creations"}),"\n",(0,s.jsx)(n.li,{children:"Periodically via a background scheduler(e.g., every 1 minutes via pg_cron)"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"globalpriorityexecutionplanner",children:"GlobalPriorityExecutionPlanner"}),"\n",(0,s.jsx)(n.p,{children:"This is the core algorithm used to compute job sort order globally across all queues:"}),"\n",(0,s.jsx)(n.h3,{id:"sort-order",children:"Sort Order:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"job_level"}),": deeper DAG jobs scheduled first"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"priority"}),": higher number = more urgent"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"free_slots"}),": more available slots preferred"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"is_new_dag"}),": existing DAGs preferred"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"estimated_runtime"}),": shorter is better"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"burst_boost"}),": recently activated DAGs prioritized"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"ascii-diagram-global-priority-execution-planner",children:"ASCII Diagram: Global Priority Execution Planner"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"+---------------------------+\n|  Marie Scheduler (_poll) |\n+---------------------------+\n             |\n             v\n  +-----------------------------+\n  | Fetch ready jobs by queue   |\n  +-----------------------------+\n             |\n             v\n  +-----------------------------+\n  | Flatten & filter jobs       |\n  +-----------------------------+\n             |\n             v\n  +---------------------------------------------+\n  | GlobalPriorityExecutionPlanner.plan()       |\n  +---------------------------------------------+\n             |\n             v\n  +--------------------------------------------------------------+\n  | Sort by:                                                     |\n  |   - job_level (desc)                                         |\n  |   - priority (desc: higher number = more urgent)             |\n  |   - free_slots (desc)                                        |\n  |   - DAG activity (existing DAGs preferred)                   |\n  |   - estimated_runtime (asc)                                  |\n  |   - burst_boost (prioritize recently activated DAGs)         |\n  +--------------------------------------------------------------+\n             |\n             v\n  +-----------------------------+\n  | Schedule jobs on executors  |\n  +-----------------------------+\n             |\n             v\n  +-----------------------------+\n  | mark_as_active(job)         |\n  |  \u2192 Marks job as active in DB|\n  |  \u2192 Activates DAG if needed  |\n  +-----------------------------+\n             |\n             v\n  +-----------------------------+\n  | enqueue(job)                |\n  |  \u2192 Sends job to executor    |\n  |  \u2192 Decrements executor slot |\n  +-----------------------------+\n             |\n             v\n  +-----------------------------+\n  | resolve_dag_status(job)     |\n  |  \u2192 Checks if DAG node is    |\n  |    terminal or unblocks next|\n  |  \u2192 Updates DAG state        |\n  +-----------------------------+\n             |\n             v\n  +-----------------------------+\n  | Await confirmation via ETCD |\n  |  \u2192 Waits for executor ack   |\n  |  \u2192 Resets scheduling state  |\n  +-----------------------------+\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"dag-level-completion",children:"DAG-Level Completion"}),"\n",(0,s.jsx)(n.p,{children:"When jobs complete, DAG state is resolved to determine if execution is finished."}),"\n",(0,s.jsx)(n.h3,{id:"ascii-diagram-dag-level-resolution-flow",children:"ASCII Diagram: DAG-Level Resolution Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"+-------------------------------+\n|  Job marked as completed      |\n+-------------------------------+\n             |\n             v\n  +-------------------------------+\n  | resolve_dag_status(job)       |\n  +-------------------------------+\n             |\n             v\n  +-------------------------------------------+\n  | Fetch DAG by dag_id                        |\n  |  \u2192 Is this the last node in the DAG?       |\n  |  \u2192 Are all downstream jobs completed?      |\n  +-------------------------------------------+\n             |\n             v\n  +-------------------------------+\n  | YES: Final job completed      |\n  | \u2192 DAG marked as completed     |\n  | \u2192 Update completed_on field   |\n  +-------------------------------+\n             |\n             v\n  | Notify and archive DAG state  |\n             |\n             v\n        [END \u2013 DAG Completed]\n\n             |\n             |\n             |\n             v\n  +-------------------------------+\n  | NO: DAG still active          |\n  | \u2192 Update internal DAG graph   |\n  | \u2192 Unblock dependent jobs      |\n  +-------------------------------+\n             |\n             v\n  | Enqueue next ready jobs       |\n  | \u2192 Re-enter scheduling loop    |\n             |\n             v\n        [CONTINUE DAG Execution]\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Marie Scheduler's planning system balances SLA pressure, system throughput, and execution fairness. It is designed to support bursty DAG workloads, enforce soft and hard deadlines, and provide predictable behavior under constrained resources."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pluggable-execution-planner-interface",children:"Pluggable Execution Planner Interface"}),"\n",(0,s.jsxs)(n.p,{children:["The Marie Scheduler supports ",(0,s.jsx)(n.strong,{children:"pluggable scheduling strategies"})," via the execution planner abstraction. This enables different scheduling policies to be used depending on system goals, workload types, or SLA conditions."]}),"\n",(0,s.jsxs)(n.h3,{id:"default-planner-globalpriorityexecutionplanner",children:["Default Planner: ",(0,s.jsx)(n.code,{children:"GlobalPriorityExecutionPlanner"})]}),"\n",(0,s.jsx)(n.p,{children:"This is the standard planner described earlier, which considers SLA priority, DAG structure, available slots, and recent DAG activity."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"alternative-planners",children:"Alternative Planners"}),"\n",(0,s.jsx)(n.p,{children:"Marie also ships with alternate planners which can be swapped dynamically:"}),"\n",(0,s.jsxs)(n.h4,{id:"hrrnexecutionplanner--highest-response-ratio-next",children:[(0,s.jsx)(n.code,{children:"HRRNExecutionPlanner"})," \u2014 Highest Response Ratio Next"]}),"\n",(0,s.jsx)(n.p,{children:"This strategy favors jobs that have waited longer relative to their estimated runtime. The formula used is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"Response Ratio = (Wait Time + Estimated Runtime) / Estimated Runtime\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Promotes fairness for long-waiting jobs"}),"\n",(0,s.jsx)(n.li,{children:"Deprioritizes new or short-duration tasks"}),"\n",(0,s.jsx)(n.li,{children:"Balances aging jobs against resource availability"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"sjfsexecutionplanner--shortest-job-first",children:[(0,s.jsx)(n.code,{children:"SJFSExecutionPlanner"})," \u2014 Shortest Job First"]}),"\n",(0,s.jsx)(n.p,{children:"This strategy prioritizes jobs with the shortest estimated runtime first:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Optimizes throughput by clearing quick jobs"}),"\n",(0,s.jsx)(n.li,{children:"Reduces average response time"}),"\n",(0,s.jsx)(n.li,{children:"May penalize long-running jobs"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"swapping-planners",children:"Swapping Planners"}),"\n",(0,s.jsxs)(n.p,{children:["To change the planner, the scheduler can be configured with a different class that implements the ",(0,s.jsx)(n.code,{children:"plan()"})," method signature:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def plan(\n    self,\n    jobs: Sequence[FlatJob],\n    slots: dict[str, int],\n    active_dags: set[str],\n    recently_activated_dags: set[str] = set(),\n) -> Sequence[FlatJob]:\n    ...\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);