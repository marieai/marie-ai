"use strict";(self.webpackChunkmare_ai=self.webpackChunkmare_ai||[]).push([[6815],{28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>a});var r=i(96540);const s={},l=r.createContext(s);function t(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(l.Provider,{value:n},e.children)}},86766:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"extract/layouts/layout-providers","title":"Layout Providers (Template Builders) \u2014 Developer Guide","description":"This guide explains how to design, register, and maintain Layout Providers (aka Template Builders). It focuses on the conceptual model, configuration patterns, and lifecycle so you can add new layouts confidently and consistently.","source":"@site/docs/extract/layouts/layout-providers.md","sourceDirName":"extract/layouts","slug":"/extract/layouts/layout-providers","permalink":"/docs/extract/layouts/layout-providers","draft":false,"unlisted":false,"editUrl":"https://github.com/marieai/marie-ai/tree/main/docs/docs/extract/layouts/layout-providers.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Extract/Layouts","permalink":"/docs/category/extractlayouts"},"next":{"title":"Extract/Processors","permalink":"/docs/category/extractprocessors"}}');var s=i(74848),l=i(28453);const t={},a="Layout Providers (Template Builders) \u2014 Developer Guide",o={},d=[{value:"What is a Layout Provider?",id:"what-is-a-layout-provider",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"Concepts and Vocabulary",id:"concepts-and-vocabulary",level:2},{value:"Lifecycle",id:"lifecycle",level:2},{value:"Registration and Discovery",id:"registration-and-discovery",level:2},{value:"Configuration-First Design",id:"configuration-first-design",level:2},{value:"Layers and Anchors",id:"layers-and-anchors",level:2},{value:"Field Mapping",id:"field-mapping",level:2},{value:"Ordering and Dependencies",id:"ordering-and-dependencies",level:2},{value:"Versioning and Compatibility",id:"versioning-and-compatibility",level:2},{value:"Testing Checklist",id:"testing-checklist",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Recommended Patterns",id:"recommended-patterns",level:2},{value:"Anti-Patterns",id:"anti-patterns",level:2},{value:"Example: Minimal YAML Skeleton",id:"example-minimal-yaml-skeleton",level:2},{value:"Quality Bar and Acceptance Criteria",id:"quality-bar-and-acceptance-criteria",level:2},{value:"Maintenance Tips",id:"maintenance-tips",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"layout-providers-template-builders--developer-guide",children:"Layout Providers (Template Builders) \u2014 Developer Guide"})}),"\n",(0,s.jsx)(n.p,{children:"This guide explains how to design, register, and maintain Layout Providers (aka Template Builders). It focuses on the conceptual model, configuration patterns, and lifecycle so you can add new layouts confidently and consistently."}),"\n",(0,s.jsx)(n.h2,{id:"what-is-a-layout-provider",children:"What is a Layout Provider?"}),"\n",(0,s.jsx)(n.p,{children:"A Layout Provider builds a Template that tells the extraction engine how to find and map fields in a specific document layout. It encapsulates:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"How to locate sections (layers) of a document."}),"\n",(0,s.jsx)(n.li,{children:"Which anchors or selectors define boundaries for each layer."}),"\n",(0,s.jsx)(n.li,{children:"How to map non-repeating fields and configure repeating structures (tables)."}),"\n",(0,s.jsx)(n.li,{children:"How the layout is registered and discovered at runtime."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In practice, a Template is composed of one or more layers, each layer targeting a coherent part of the document (for example, header, claim details, remarks, tables)."}),"\n",(0,s.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Validate the incoming configuration (e.g., the layout ID and layer keys exist)."}),"\n",(0,s.jsx)(n.li,{children:"Build a Template object for a single layout ID."}),"\n",(0,s.jsxs)(n.li,{children:["Create and configure one or more layers:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Define start/stop anchors or selector sets for each layer."}),"\n",(0,s.jsx)(n.li,{children:"Map non-repeating fields to selectors."}),"\n",(0,s.jsx)(n.li,{children:"Provide repeating-field/table configuration."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Add layers to the Template in the correct order (when layers are interdependent)."}),"\n",(0,s.jsx)(n.li,{children:"Return a fully formed Template to the engine."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"concepts-and-vocabulary",children:"Concepts and Vocabulary"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Layout ID: A unique identifier for a layout that determines which Template Builder to use."}),"\n",(0,s.jsx)(n.li,{children:"Template: The assembled structure passed to the extraction engine."}),"\n",(0,s.jsx)(n.li,{children:"Layer: A \u201csection\u201d of the document governed by start/stop anchors (or selectors) and containing field mappings and/or tables."}),"\n",(0,s.jsx)(n.li,{children:"Anchors/Selectors: Patterns or rules that identify where a layer starts or stops and how fields are captured."}),"\n",(0,s.jsx)(n.li,{children:"Non-repeating fields: Single-value fields within a layer (e.g., Claim Number)."}),"\n",(0,s.jsx)(n.li,{children:"Repeating fields / Tables: Structured, repeating data captured as one or more rows."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"lifecycle",children:"Lifecycle"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The engine identifies layout_id in the runtime config and locates the matching Layout Provider (registration)."}),"\n",(0,s.jsx)(n.li,{children:"The provider validates config and constructs a Template."}),"\n",(0,s.jsx)(n.li,{children:"The provider defines layers with start/stop conditions (anchors/selectors), field mappings, and table configurations."}),"\n",(0,s.jsx)(n.li,{children:"The provider returns the Template to the engine for parsing and extraction."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"registration-and-discovery",children:"Registration and Discovery"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each Layout Provider is associated with a single layout ID."}),"\n",(0,s.jsx)(n.li,{children:"Providers are registered with the extraction framework under their layout ID."}),"\n",(0,s.jsx)(n.li,{children:"At runtime, the engine loads the provider for the current layout_id and calls the builder to obtain the Template."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Tip: Keep one provider per layout ID and keep the ID stable across releases. If a breaking change to the layout occurs, prefer introducing a new layout ID."}),"\n",(0,s.jsx)(n.h2,{id:"configuration-first-design",children:"Configuration-First Design"}),"\n",(0,s.jsx)(n.p,{children:"Layout Providers are driven by configuration to minimize branching logic in code. Typical config themes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"selectors.start and selectors.stop per layer"}),"\n",(0,s.jsx)(n.li,{children:"fields.non_repeating and fields.repeating definitions"}),"\n",(0,s.jsx)(n.li,{children:"layer-specific mapping and optional overrides"}),"\n",(0,s.jsx)(n.li,{children:"table schemas and header/column matchers"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This separation allows you to evolve extraction patterns mostly through configuration."}),"\n",(0,s.jsx)(n.h2,{id:"layers-and-anchors",children:"Layers and Anchors"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Start/stop anchors (or selector sets) define the scope for each layer."}),"\n",(0,s.jsx)(n.li,{children:"A layer processes content only within its boundaries."}),"\n",(0,s.jsx)(n.li,{children:"When layers have dependencies, add them to the Template in the dependency order. For example, a \u201cremarks\u201d layer might constrain or influence adjacent regions."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Examples of common layer patterns:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Main/Claims layer: general header and claim-level information."}),"\n",(0,s.jsx)(n.li,{children:"Remarks layer: a bounded region based on remark headers/footers."}),"\n",(0,s.jsx)(n.li,{children:"Table layer(s): one or more repeating structures positioned by section anchors."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"field-mapping",children:"Field Mapping"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Non-repeating fields:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Map each field to a selector set that identifies the value in the layer\u2019s region."}),"\n",(0,s.jsx)(n.li,{children:"Use the field key as the default name when not explicitly declared in field definitions."}),"\n",(0,s.jsx)(n.li,{children:"Keep required/primary flags consistent with downstream validation rules."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Repeating fields/Tables:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provide a raw table configuration (column specs, header patterns, line-item detection)."}),"\n",(0,s.jsx)(n.li,{children:"Prefer config-driven approaches so table extraction logic doesn\u2019t need code changes for each layout."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"ordering-and-dependencies",children:"Ordering and Dependencies"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The order you add layers to the Template can be significant when layers constrain or inform each other."}),"\n",(0,s.jsxs)(n.li,{children:["Guideline:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Add ancillary or bounding layers first (e.g., remarks/notes, sectional bounds)."}),"\n",(0,s.jsx)(n.li,{children:"Add primary content layers (e.g., main/claims) next."}),"\n",(0,s.jsx)(n.li,{children:"Add table layers last unless a preceding layer depends on table boundaries."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"versioning-and-compatibility",children:"Versioning and Compatibility"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Template version: Bump the version when you introduce non-trivial changes."}),"\n",(0,s.jsx)(n.li,{children:"Backwards compatibility: If the layout on documents changes meaningfully, create a new layout ID rather than forcing complex conditionals."}),"\n",(0,s.jsx)(n.li,{children:"Config evolution: Keep config changes backward compatible where feasible; document breaking changes clearly."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"testing-checklist",children:"Testing Checklist"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Configuration validation:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Missing layout_id is rejected with a clear error."}),"\n",(0,s.jsx)(n.li,{children:"Unknown layout_id is rejected with a clear error."}),"\n",(0,s.jsx)(n.li,{children:"Mandatory config sections exist (layers, selectors, fields)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Layer anchoring:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Start/stop anchors correctly bound each layer for sample docs."}),"\n",(0,s.jsx)(n.li,{children:"Overlapping or unbounded layers are handled or flagged."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Field mapping:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Non-repeating fields found reliably across representative samples."}),"\n",(0,s.jsx)(n.li,{children:"Required fields trigger validation failures when missing."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Tables:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Column identification works with header variations."}),"\n",(0,s.jsx)(n.li,{children:"Row segmentation handles multi-line cells and noise."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["End-to-end:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Extracted output matches expected field maps for multiple real samples."}),"\n",(0,s.jsx)(n.li,{children:"Performance and stability under typical and stress inputs."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A layer isn\u2019t detected:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check that start/stop anchors are present, spelled correctly, and not overly strict."}),"\n",(0,s.jsx)(n.li,{children:"Verify the layer order if dependencies exist."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["A field is empty or inconsistent:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Inspect the selector set specificity; broaden or refine as needed."}),"\n",(0,s.jsx)(n.li,{children:"Confirm the field region truly lies within the layer bounds."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Table columns are misaligned:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Revisit header detection rules and permissible variations."}),"\n",(0,s.jsx)(n.li,{children:"Consider adding fallback column locators or widening tolerance."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Config loads but extraction fails:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ensure required fields or tables are correctly flagged or made optional."}),"\n",(0,s.jsx)(n.li,{children:"Add explicit errors in config validation to fail fast."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"recommended-patterns",children:"Recommended Patterns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Prefer config-driven selector sets over code branching."}),"\n",(0,s.jsx)(n.li,{children:"Keep anchor terms concise and semantically strong."}),"\n",(0,s.jsx)(n.li,{children:"Group related layers and keep naming consistent across layouts."}),"\n",(0,s.jsx)(n.li,{children:"Document non-obvious assumptions in the config (e.g., \u201cremarks section ends at \u2018REMARK_END\u2019 marker\u201d)."}),"\n",(0,s.jsx)(n.li,{children:"Treat tables as first-class: define robust header/column matching and row segmentation rules in config."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"anti-patterns",children:"Anti-Patterns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Hardcoding field logic in the builder when a selector could express it."}),"\n",(0,s.jsx)(n.li,{children:"Overlapping layers that depend on implicit ordering rather than explicit boundaries."}),"\n",(0,s.jsx)(n.li,{children:"Silent fallbacks: Emit explicit errors when required elements aren\u2019t found."}),"\n",(0,s.jsx)(n.li,{children:"Monolithic \u201ccatch-all\u201d layers with ambiguous anchors."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-minimal-yaml-skeleton",children:"Example: Minimal YAML Skeleton"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'layout_id: TID-XXXXX\n\nselectors:\n  # Defaults or layer-agnostic selectors (optional)\n  # Usually layer selectors live inside each layer config.\n  start: []\n  stop: []\n\nlayers:\n  layer-main:\n    selectors:\n      start: ["CLAIM NUMBER", "PATIENT ACCOUNT", "EMPLOYEE", "PROVIDER TAX ID"]\n      stop: []  # Optional: could be implicit end of page/section\n    non_repeating_fields:\n      claim_number:\n        # Field-specific selectors live here; structure depends on your selector schema\n        annotation_selectors:\n          - ["CLAIM NUMBER", ":right-of", ":same-line"]\n      patient_account:\n        annotation_selectors:\n          - ["PATIENT ACCOUNT", ":right-of", ":same-line"]\n    tables:\n      - name: line_items\n        header_selectors:\n          - ["DOS", "CPT", "CHARGES", "PAID"]  # Example headers\n        columns:\n          - { key: service_date, patterns: ["DOS", "DATE"] }\n          - { key: cpt_code, patterns: ["CPT", "PROC"] }\n          - { key: charge_amount, patterns: ["CHARGES", "BILLED"] }\n          - { key: paid_amount, patterns: ["PAID", "ALLOWED"] }\n\n  layer-remarks:\n    selectors:\n      start: ["REMARK_START"]\n      stop: ["REMARK_END"]\n    non_repeating_fields:\n      remarks_text:\n        annotation_selectors:\n          - ["*"]  # Everything inside the bounded region, per your selector semantics\n\nfields:\n  non_repeating:\n    claim_number:\n      name: Claim Number\n      required: true\n    patient_account:\n      name: Patient Account\n      required: false\n    remarks_text:\n      name: Remarks\n      required: false\n\n  repeating:\n    line_items:\n      # Table-level metadata and normalizers go here\n      required: false\n'})}),"\n",(0,s.jsx)(n.p,{children:"Notes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The exact schema for selectors and field definitions should match your project\u2019s selector/annotation conventions."}),"\n",(0,s.jsx)(n.li,{children:"Keep layer names stable; they are used across configs, code integration, and tests."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"quality-bar-and-acceptance-criteria",children:"Quality Bar and Acceptance Criteria"}),"\n",(0,s.jsx)(n.p,{children:"A new Layout Provider is considered complete when:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It is registered under a unique, stable layout ID."}),"\n",(0,s.jsx)(n.li,{children:"It validates configuration properly and fails fast on misconfiguration."}),"\n",(0,s.jsx)(n.li,{children:"It builds a Template with correctly ordered layers."}),"\n",(0,s.jsx)(n.li,{children:"It reliably extracts required fields and tables across representative samples."}),"\n",(0,s.jsx)(n.li,{children:"It includes tests for config validation, anchoring, field mapping, and tables."}),"\n",(0,s.jsxs)(n.li,{children:["It is documented:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The intent of each layer."}),"\n",(0,s.jsx)(n.li,{children:"Key anchors and non-obvious rules."}),"\n",(0,s.jsx)(n.li,{children:"Known limitations and edge cases."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"maintenance-tips",children:"Maintenance Tips"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Keep a changelog of layout-specific adjustments tied to sample documents."}),"\n",(0,s.jsx)(n.li,{children:"Capture heuristics in config comments; avoid institutional knowledge siloing."}),"\n",(0,s.jsx)(n.li,{children:"When anchor text changes in new document batches, evolve selectors conservatively and add tests using the new samples."}),"\n",(0,s.jsx)(n.li,{children:"If a change risks breaking existing datasets, introduce a new layout ID."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);