"use strict";(self.webpackChunkmare_ai=self.webpackChunkmare_ai||[]).push([[5520],{28427:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"extract/annotators/annotators","title":"Purpose and How They Fit Into the System","description":"This document explains what \u201cannotators\u201d are in the extraction pipeline, why they exist, and how to choose and use them effectively.","source":"@site/docs/extract/annotators/annotators.md","sourceDirName":"extract/annotators","slug":"/extract/annotators/","permalink":"/docs/extract/annotators/","draft":false,"unlisted":false,"editUrl":"https://github.com/marieai/marie-ai/tree/main/docs/docs/extract/annotators/annotators.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Configuration: directory structure, prompt resolution, and examples","permalink":"/docs/extract/annotators/annotators-config"},"next":{"title":"Extract/Layouts","permalink":"/docs/category/extractlayouts"}}');var s=t(74848),r=t(28453);const a={},o="Purpose and How They Fit Into the System",l={},c=[{value:"What is an Annotator?",id:"what-is-an-annotator",level:2},{value:"Why Annotators Exist",id:"why-annotators-exist",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"The Main Annotator Types",id:"the-main-annotator-types",level:2},{value:"Where Annotators Fit in the Pipeline",id:"where-annotators-fit-in-the-pipeline",level:2},{value:"Inputs and Outputs (Conceptual)",id:"inputs-and-outputs-conceptual",level:2},{value:"Choosing the Right Annotator",id:"choosing-the-right-annotator",level:2},{value:"Extending the System with a New Annotator",id:"extending-the-system-with-a-new-annotator",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"purpose-and-how-they-fit-into-the-system",children:"Purpose and How They Fit Into the System"})}),"\n",(0,s.jsx)(e.p,{children:"This document explains what \u201cannotators\u201d are in the extraction pipeline, why they exist, and how to choose and use them effectively."}),"\n",(0,s.jsx)(e.h2,{id:"what-is-an-annotator",children:"What is an Annotator?"}),"\n",(0,s.jsx)(e.p,{children:"An annotator is a pluggable component that enriches a document with machine-generated labels, structure, or extracted values. Think of an annotator as a focused \u201cskill\u201d that:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Reads an unstructured or semi-structured document representation (text, pages, OCR, regions)."}),"\n",(0,s.jsx)(e.li,{children:"Applies a strategy (rules, embeddings, LLMs, etc.) to identify or extract information."}),"\n",(0,s.jsx)(e.li,{children:"Emits structured results and artifacts that downstream steps can rely on."}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Annotators expose a common interface and declare their capabilities, making them easy to orchestrate, swap, and compose."}),"\n",(0,s.jsx)(e.h2,{id:"why-annotators-exist",children:"Why Annotators Exist"}),"\n",(0,s.jsx)(e.p,{children:"Annotators exist to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Standardize extraction logic across document types and models."}),"\n",(0,s.jsx)(e.li,{children:"Separate concerns between \u201chow to find data\u201d and \u201chow to run workflows.\u201d"}),"\n",(0,s.jsx)(e.li,{children:"Enable hybrid strategies (rule-based + ML/LLM + retrieval) without changing the rest of the system."}),"\n",(0,s.jsx)(e.li,{children:"Improve reproducibility and auditability by writing outputs to predictable locations and keeping a consistent API."}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Capability declaration:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Annotators declare what they can do (e.g., EXTRACTOR, SEGMENTER). Orchestration can route documents to the right tool based on these capabilities."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Configuration-driven:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Annotators are configured per layout/use-case. Configs define annotator identity, model options, prompts or rules, and expected outputs."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Document contract:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Annotators operate on an internal \u201cunstructured document\u201d representation (text, OCR, page frames, regions, metadata)."}),"\n",(0,s.jsx)(e.li,{children:"They should validate inputs and fail early when preconditions are not met."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Deterministic side effects:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Each annotator writes its artifacts to a dedicated output directory for the request/context. This allows idempotent runs, caching, and debugging."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Synchronous and asynchronous operation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Annotators may support both sync and async execution, which helps in scaling and distributed processing."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"the-main-annotator-types",children:"The Main Annotator Types"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Rule-based (Regex Annotator)"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Purpose: Fast, deterministic extraction when field patterns are stable (IDs, dates, totals)."}),"\n",(0,s.jsx)(e.li,{children:"Strengths: Simple, explainable, low cost, high precision when patterns are well-defined."}),"\n",(0,s.jsx)(e.li,{children:"Use when: You have reliable string patterns and want speed and predictability."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"LLM Annotator"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Purpose: Use a language model to interpret content and extract fields, labels, or regions\u2014optionally multimodal (image + text)."}),"\n",(0,s.jsx)(e.li,{children:"Strengths: Robust to variation, can infer semantics, good for complex or loosely structured documents."}),"\n",(0,s.jsx)(e.li,{children:"Use when: Layouts vary, semantics matter, or you need flexible reasoning beyond strict patterns."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"LLM Table Annotator"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Purpose: Specialization focused on detecting, understanding, and extracting tabular content via LLM prompts."}),"\n",(0,s.jsx)(e.li,{children:"Strengths: Handles fragmented tables, headers, and row/column semantics."}),"\n",(0,s.jsx)(e.li,{children:"Use when: You need to reliably extract tabular data across varied document layouts."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Embedding/Retrieval Hybrid Annotator"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Purpose: Combine semantic embeddings, fuzzy matching, and memory of known labels to extract fields with high recall and robustness."}),"\n",(0,s.jsx)(e.li,{children:"Strengths: Handles noisy OCR, misspellings, and partial matches; leverages retrieval to rank candidates."}),"\n",(0,s.jsx)(e.li,{children:"Use when: Terminology and formatting vary widely or OCR is noisy, and you want resilient matching beyond rules."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"where-annotators-fit-in-the-pipeline",children:"Where Annotators Fit in the Pipeline"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Orchestration (executors) invokes annotators based on operation parameters and layout configs."}),"\n",(0,s.jsx)(e.li,{children:"Documents are prepared (pages/frames, OCR, metadata) and passed to the chosen annotator."}),"\n",(0,s.jsx)(e.li,{children:"Annotators write their outputs (e.g., JSON results, intermediate artifacts) into a known output directory for the current job/context."}),"\n",(0,s.jsx)(e.li,{children:"Downstream components consume these structured results for final parsing, validation, and API responses."}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"inputs-and-outputs-conceptual",children:"Inputs and Outputs (Conceptual)"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Inputs:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"A document abstraction with text/OCR, page frames, and metadata."}),"\n",(0,s.jsx)(e.li,{children:"Annotator configuration (name, model/rules, prompt, expected schema)."}),"\n",(0,s.jsx)(e.li,{children:"Optional runtime parameters (job identifiers, layout keys, etc.)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Outputs:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Structured extraction results (e.g., field/value pairs, confidence)."}),"\n",(0,s.jsx)(e.li,{children:"Optional artifacts (image snippets, logs, intermediate files) useful for traceability and debugging."}),"\n",(0,s.jsx)(e.li,{children:"Parsers can further normalize these outputs into the system\u2019s canonical schema."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"choosing-the-right-annotator",children:"Choosing the Right Annotator"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Choose Rule-based when:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Fields are well-known and consistently formatted."}),"\n",(0,s.jsx)(e.li,{children:"You need predictable, transparent behavior and speed."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Choose LLM when:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Documents vary in structure/wording."}),"\n",(0,s.jsx)(e.li,{children:"You need semantic understanding or reasoning."}),"\n",(0,s.jsx)(e.li,{children:"You\u2019re okay with model latency and cost trade-offs."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Choose LLM Table when:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Tabular structures are central to the task."}),"\n",(0,s.jsx)(e.li,{children:"You want improved accuracy on table-specific semantics."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Choose Embedding/Hybrid when:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Data is noisy or inconsistent."}),"\n",(0,s.jsx)(e.li,{children:"You need a balance of recall and precision with fuzzy/semantic matching."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Often, combining annotators yields the best results: use fast regex for easy wins and fall back to LLM/Hybrid for hard cases."}),"\n",(0,s.jsx)(e.h2,{id:"extending-the-system-with-a-new-annotator",children:"Extending the System with a New Annotator"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Implement the common annotator contract:","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Declare capabilities."}),"\n",(0,s.jsx)(e.li,{children:"Validate document input."}),"\n",(0,s.jsx)(e.li,{children:"Implement annotate/aannotate and output parsing."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["Keep configuration external:","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Don\u2019t hardcode model names or prompts\u2014load from config."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["Write reproducible outputs:","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Use a dedicated output path per annotator and request context."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["Make it composable:","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Favor structured outputs that downstream parsers can consume."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Idempotency:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Skip work if outputs already exist for the current context; allows retries without reprocessing everything."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Observability:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Log configuration and important runtime parameters (model, prompt, output path)."}),"\n",(0,s.jsx)(e.li,{children:"Persist intermediate artifacts where helpful."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Guardrails:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Validate inputs early and clearly."}),"\n",(0,s.jsx)(e.li,{children:"Apply timeouts and error handling to avoid blocking pipelines."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Performance:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Use the simplest annotator that achieves the goal."}),"\n",(0,s.jsx)(e.li,{children:"Partition work across pages/regions to exploit parallelism."}),"\n",(0,s.jsx)(e.li,{children:"Cache models/embeddings where possible."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Quality:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"For LLMs, control prompts, temperature/top-p, and expected schemas."}),"\n",(0,s.jsx)(e.li,{children:"For hybrid approaches, tune thresholds and weights and maintain label memory."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"Annotators are the building blocks of the extraction system. They provide a consistent, configurable way to enrich documents with structured information\u2014whether by simple rules, powerful language models, or hybrid semantic matching. By standardizing capabilities, inputs/outputs, and execution patterns, annotators make the pipeline flexible, scalable, and maintainable while enabling high-quality document understanding."})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function a(n){const e=i.useContext(r);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);